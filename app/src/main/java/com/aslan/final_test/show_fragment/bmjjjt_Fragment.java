package com.aslan.final_test.show_fragment;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.aslan.final_test.R;

public class bmjjjt_Fragment extends Fragment {
    private TextView v2;
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = LayoutInflater.from(getActivity()).inflate(R.layout.bmjjjt,container,false);

        v2=(TextView)view.findViewById(R.id.bmjj2);
        String tv2="    补码除法其符号位和数值部分是一起参加运算的，因此在算法上不像原码除法那样直观，主要需解决三个问题：\n" +
                "    第一，如何确定商值；\n" +
                "    第二，如何形成商符；\n" +
                "    第三，如何获得新的余数。\n" +
                "\n" +
                "　　①商值的确定。欲确定商值，必须先比较被除数和除数的大小，然后才能求得商值。\n" +
                "　　a． 比较被除数(余数)和除数的大小。补码除法的操作数均为补码，其符号又是任意的，因此要比较被除数[x]补和除数[y]补的大小就不能简单地用[x]补减去[y]补。实质上比较[x]补和[y]补的大小就是比较它们所对应的绝对值的大小。同样在求商的过程中，比较余数[Ri]补与除数[y]补的大小，也是比较它们所对应的绝对值。这种比较的算法可归纳为以下两点：\n" +
                "　　第一，当被除数与除数同号时，做减法，若得到的余数与除数同号，表示“够减”，否则表示“不够减”。\n" +
                "　　第二，当被除数与除数异号时，做加法，若得到的余数与除数异号，表示“够减”，否则表示“不够减”。\n" +
                "\n" +
                "      b．商值的确定。补码除法的商也是用补码表示的，如果我们约定商的末位用“恒置1”的舍入规则，那么除末位商外，其余各位的商值对正商和负商而言，上商规则是不同的。因为在负商的情况下，除末位商以外，其余任何一位的商与真值都正好相反。因此，上商的算法可归纳为以下两点：\n" +
                "　　第一，如果[x]补与[y]补同号，商为正，则“够减”时上商“1”。“不够减”时上商“0”(按原码规则上商)。\n" +
                "　　第二，如果[x]补与[y]补异号，商为负，则“够减”时上商“0”，“不够减”时上商“1”(按反码规则上商)。\n" +
                "\n" +
                "      ②商符的形成。在补码除法中，商符是在求商的过程中自动形成的。\n" +
                "　　 在小数定点除法中，被除数的绝对值必须小于除数的绝对值，否则商大于1而溢出。因此，当[x]补与[y]补同号时，[x]补-[y]补所得的余数[R0]补与[y]补异号，商上“0”，恰好与商的符号(正)一致；当[x]补与[y]补异号时，[x]补+[y]补所得的余数[R0]补与[y]补同号，商上“1”，这也与商的符号(负)一致。可见，商符是在求商值过程中自动形成的。\n" +
                "　　此外，商的符号还可用来判断商是否溢出。例如，当[x]补与[y]补同号时，若[R0]补与[y]补同号，上商“l”，即溢出。当[x]补与[y]补异号时，若[R0]补与[y]补异号，上商“0”，即溢出。\n" +
                "　　当然，对于小数补码运算，商等于“-1”应该是允许的，但这需要特殊处理，为简化问题，这里不予考虑。\n" +
                "\n" +
                "　　③新余数[Ri+1]补的获得。\n" +
                "　　新余数[Ri+1]补的获得方法与原码加减交替法极相似，其算法规则为：\n" +
                "　　当[R0]补与[y]补同号时，商上“l”，新余数\n" +
                "　　　[Ri+1]补=2[Ri]补-[y]补=2[Ri]补+[-y]补\n" +
                "　　当[R0]补与[y]补异号时，商上“0”，新余数\n" +
                "　　　[Ri+1]补=2[Ri]补+[y]补\n" +
                "      如果对商的精度没有特殊要求，一般可采用“末位恒置1”法，这种方法操作简单，易于实现，而且最大误差仅为2-n。\n" +
                "\n" +
                "      例：已知：x=-0.1001, y=+0.1101 求： [x÷y]补\n" +
                "　　解：[x]补=1.0111,[y]补=0.1101,[-y]补=1.0011\n" +
                "　　运算过程如下：";
        v2.setText(tv2);

        return view;
    }
}
